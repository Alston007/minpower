
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>powersystems &mdash; minpower</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1 alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://mathjax.connectmv.com/MathJax.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="minpower" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24659622-2']);
  _gaq.push(['_trackPageview']);
</script>
<script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>

  </head>
  <body>  

    <div class="document">

      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for powersystems</h1><pre>
:class:`~powersystems.Bus`, :class:`~powersystems.Generator`, 
:class:`~powersystems.Line`, and :class:`~powersystems.Load`.
"""
import bidding
from optimization import newVar,value,sumVars
from commonscripts import hours,subset,subsetexcept,drop_case_spaces,getattrL,flatten
import config
import logging

from dateutil.relativedelta import relativedelta
import numpy 

def makeGenerator(kind='generic',**kwargs):
    """
<div class="viewcode-block" id="makeGenerator"><a class="viewcode-back" href="../documentation.html#powersystems.makeGenerator">[docs]</a>    Create a :class:`~powersystems.Generator` object 
    (or a :class:`~powersystems.Generator_nonControllable`
    object depending on the kind). First parses defaults
    from :mod:`config`, depending on the kind.
    
    :param kind: define the kind of generator (all 
        kinds are defined in :data:`config.generator_kinds`)
    
    Other parameters are detailed in :class:`~powersystems.Generator`.
    
    :returns: a :class:`~powersystems.Generator` object
    """

    def parse_args(kind,**inputs):
        '''check kind pull defaults from the config file'''
        kind=drop_case_spaces(kind)
        if kind not in config.generator_kinds:
            logging.warning('"k" is an unknown kind of generator, using generic defaults.'.format(k=kind))
            kind='generic'
        
        #get defaults from config file
        defaults=dict()
        for name,val in config.generator_defaults.iteritems():
            try: defaults[name]=val[kind]
            except KeyError:
                logging.debug('no {d} default found for kind "{k}", using default from generic.'.format(d=name,k=kind))
                defaults[name]=val['generic']
            except TypeError: 
                defaults[name]=val #no kind-distincted defaults
                
        #use the values that are defined in the inputs
        outputs=defaults
        outputs.update(inputs)
        return kind,outputs
    
    
    kind,kwargs=parse_args(kind,**kwargs)    
    if kind=='wind' or not kwargs['isControllable'] or kwargs.get('schedule',None): 
        classname=Generator_nonControllable
    else: classname=Generator
    kwargs.pop('isControllable')
    return classname(kind=kind,**kwargs)

def makeLoad(kind='varying',**kwargs):
    """</div>
<div class="viewcode-block" id="makeLoad"><a class="viewcode-back" href="../documentation.html#powersystems.makeLoad">[docs]</a>    Create a :class:`~powersystems.Load` object (if a power 
    :class:`~schedule.Schedule` is specified) or a
    :class:`~powersystems.Load_Fixed` object (if a single
    power value :attr:`P` is specified).
    """
    if 'P' in kwargs.keys(): return Load_Fixed(kind=kind, **kwargs)
    else: return Load(kind=kind,**kwargs)
        
class Generator(object):
    """</div>
<div class="viewcode-block" id="Generator"><a class="viewcode-back" href="../documentation.html#powersystems.Generator">[docs]</a>    A generator model. 
    
    :param Pmin: minimum real power
    :param Pmax: maximum real power
    :param minuptime: min. time after commitment in on status (hours)
    :param mindowntime: min. time after de-commitment in off status (hours)
    :param rampratemax: max. positive change in real power over 1hr (MW/hr)
    :param rampratemin: max. negative change in real power over 1hr (MW/hr)
    :param costcurvestring: text describing a polynomial cost curve ($/MWh)
      see :meth:`~bidding.parsePolynomial` for more.
    :param heatratestring: text describing a polynomial heat rate curve (MBTU/MW). 
        converts to cost curve when multiplied by fuelcost.
    :param fuelcost: cost of fuel ($/MBTU)
    :param startupcost: cost to commit ($)
    :param shutdowncost: cost to de-commit ($)
    :param mustrun: flag that forces commimtent to be on

    :param name: name of the generator
    :param index: numbering of the generator    
    :param bus: bus name that the generator is connected to 
    """

    def __init__(self,kind='generic',
        Pmin=0,Pmax=500,
        minuptime=0,mindowntime=0,
        rampratemax=1000,rampratemin=None,
        costcurvestring='20P',
        heatratestring=None,fuelcost=1,
        startupcost=0,shutdowncost=0,
        mustrun=False,
        name='',index=None,bus=None):
        
        vars(self).update(locals()) #load in inputs
        if index is None: self.index=hash(self)        
        if self.rampratemin is None: self.rampratemin = -1*self.rampratemax
        
        self.buildCostModel()
        self._makeEmpties()
        self.isControllable=True
    def buildCostModel(self):
        ''' create a cost model for bidding with :meth:`~bidding.makeModel` '''
<div class="viewcode-block" id="Generator.buildCostModel"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.buildCostModel">[docs]</a>        if getattr(self,'heatratestring',None) is not None: 
            costinputs=dict(polyText=self.heatratestring,multiplier=self.fuelcost)
            self.costcurvestring=None
        else: 
            costinputs=dict(polyText=self.costcurvestring)
            self.fuelcost=1
        self.costModel=bidding.makeModel(minInput=self.Pmin, maxInput=self.Pmax,inputNm='Pg',outputNm='C',**costinputs)
    def _makeEmpties(self): self.u,self.power,self.bid,self.startup,self.shutdown=dict(),dict(),dict(),dict(),dict()
        </div>
    def P(self,time=None): 
        '''real power output at time'''
<div class="viewcode-block" id="Generator.P"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.P">[docs]</a>        return self.power[time]
    def status(self,time): 
        '''on/off status at time'''</div>
<div class="viewcode-block" id="Generator.status"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.status">[docs]</a>        return self.u[time]
    def cost(self,time): 
        '''total cost at time (operating + startup + shutdown)'''</div>
<div class="viewcode-block" id="Generator.cost"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.cost">[docs]</a>        return self.operatingcost(time)+self.startupcost*self.startup[time]+self.shutdowncost*self.shutdown[time]
    def operatingcost(self,time): 
        '''cost of real power production at time (based on bid model approximation).'''</div>
<div class="viewcode-block" id="Generator.operatingcost"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.operatingcost">[docs]</a>        return self.bid[time].output()
    def truecost(self,time):
        '''exact cost of real power production at time (based on exact bid polynomial).'''</div>
<div class="viewcode-block" id="Generator.truecost"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.truecost">[docs]</a>        return value(self.u[time])*self.costModel.trueOutput(self.P(time))
    def incrementalcost(self,time): 
        '''change in cost with change in power at time (based on exact bid polynomial).'''</div>
<div class="viewcode-block" id="Generator.incrementalcost"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.incrementalcost">[docs]</a>        return self.bid[time].incOutput(self.P(time)) if value(self.u[time]) else None
    def getstatus(self,t,times): return dict(u=value(self.u[t]),P=value(self.P(t)),hoursinstatus=self.gethrsinstatus(t,times))
    def gethrsinstatus(self,tm,times):</div>
<div class="viewcode-block" id="Generator.getstatus"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.getstatus">[docs]</a>        status=value(self.u[tm])</div>
<div class="viewcode-block" id="Generator.gethrsinstatus"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.gethrsinstatus">[docs]</a>        timesClipped=times[:times.index(tm)]
        try: 
            t_lastchange=(t for t in reversed(timesClipped) if value(self.u[t])!=status ).next()
            return hours(tm-t_lastchange)
        except StopIteration: #no changes over whole time period
            h=hours(tm-times[0])
            if value(self.u[times.initialTime]) == status: h+=self.initialStatusHours
            return h
        
    def add_timevars(self,times,dispatch_decommit_allowed=False):
        '''set up dicts for time-varying optimization variables</div>
<div class="viewcode-block" id="Generator.add_timevars"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.add_timevars">[docs]</a>        (power,u,startup,shutdown,bid)
        '''
        
        allvars=[]
        commitment_problem= len(times)&gt;1 or dispatch_decommit_allowed
        for time in times:    
            iden=self.iden(time)
            self.power[time]=newVar(name='P_'+iden,low=self.Pmin,high=self.Pmax)

            
            if commitment_problem: #UC problem
                self.u[time]=newVar(name='u_'+iden,kind='Binary')
                self.startup[time] =newVar(name='su_'+iden,kind='Binary')
                self.shutdown[time]=newVar(name='sd_'+iden,kind='Binary')
                allvars.extend([self.u[time],self.startup[time],self.shutdown[time]])
            else: #ED or OPF problem, no commitments
                self.u[time]=True
                self.startup[time]=False
                self.shutdown[time]=False

            self.bid[time]=bidding.Bid(
                model=self.costModel,
                inputvar=self.power[time],
                statusvar=self.u[time],
                iden=self.iden(time)
                )
            allvars.extend([self.power[time]])
            allvars.extend(self.bid[time].add_timevars())


        return allvars
    
    def update_vars(self,times,problem):
        #commitment_problem= len(times)&gt;1</div>
<div class="viewcode-block" id="Generator.update_vars"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.update_vars">[docs]</a>        for time in times:
            self.power[time] = value(self.power[time],problem)
            self.bid[time].update_vars(problem)
            #if commitment_problem: #UC problem
            self.u[time]=value(self.u[time],problem)
            self.startup[time] =value(self.startup[time],problem)
            self.shutdown[time]=value(self.shutdown[time],problem)
        
            
    def fix_vars(self,times,problem):
        self.update_vars(times,problem)</div>
<div class="viewcode-block" id="Generator.fix_vars"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.fix_vars">[docs]</a>        self.bid={} #wipe bid info - no longer needed

    def plotCostCurve(self,P=None,filename=None): self.costModel.plot(P,filename)
    def setInitialCondition(self,time=None, P=None, u=True, hoursinstatus=100):</div>
<div class="viewcode-block" id="Generator.plotCostCurve"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.plotCostCurve">[docs]</a>        if P is None: P=(self.Pmax-self.Pmin)/2 #set default power as median output</div>
<div class="viewcode-block" id="Generator.setInitialCondition"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.setInitialCondition">[docs]</a>        self.u[time]=u
        self.power[time]=P*u  #note: this eliminates ambiguity of off status with power non-zero output
        self.initialStatusHours = hoursinstatus
        self.startup[time]= True if self.initialStatusHours==0 and self.u[time] else False
        self.shutdown[time]=True if self.initialStatusHours==0 and not self.u[time] else False

    def constraints(self,times):
        '''create the optimization constraints for a generator over all times'''</div>
<div class="viewcode-block" id="Generator.constraints"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.constraints">[docs]</a>        constraintsD=dict()
        
        commitment_problem= len(times)&gt;1
                
        if commitment_problem:
            iden='{g}_init'.format(g=str(self))
            #initial time
            tInitial = times.initialTime
            startTime = times[0].Start
            tEndHours = relativedelta(times[-1].Start, times[0].Start).hours
            tEndIndex = len(times)
            minUpHoursRemainingInit = max(0, (self.u[tInitial]==1) * min(tEndHours, self.minuptime - self.initialStatusHours))
            minDnHoursRemainingInit = max(0, (self.u[tInitial]==0) * min(tEndHours, self.mindowntime - self.initialStatusHours))
            #initial up down time
            def roundoff(n):
                if type(n) is float: 
                    if n!=int(n): raise ValueError('min up downtimes must be integer hours, not {}'.format(n))
                    n=int(n)
                return n
            if minUpHoursRemainingInit&gt;0: constraintsD['minuptime_'+iden]= 0==sumVars([(1-self.u[times[t]]) for t in range(0,roundoff(minUpHoursRemainingInit/times.intervalhrs))])
            if minDnHoursRemainingInit&gt;0: constraintsD['mindowntime_'+iden]= 0==sumVars([self.u[times[t]] for t in range(0,roundoff(minDnHoursRemainingInit/times.intervalhrs))])
            #initial start up / shut down
            constraintsD['statusChange_'+iden]= self.startup[times[0]]-self.shutdown[times[0]] == self.u[times[0]] - self.u[tInitial]
            #initial ramp rate
            constraintsD['rampingLimHi_'+iden]=                     self.P(times[0]) - self.P(tInitial) &lt;= self.rampratemax
            constraintsD['rampingLimLo_'+iden]= self.rampratemin &lt;=     self.P(times[0]) - self.P(tInitial)
        else: #fix status for ED,OPF problems
            if self.u[times[0]] in (True, False):
                pass #gen status fixed for dispatch period
            elif self.u[times[0]].value is None: 
                pass #variable because dispatch_decommit_allowed
            else: 
                raise TypeError
                
        
        for t,time in enumerate(times):
            iden=self.iden(time)
            #must run
            if self.mustrun: self.u[time] = True #overwrite the variable with a true
            #bid constraints
            constraintsD.update( self.bid[time].constraints() )
            #min/max power
            constraintsD['min-gen-power_'+iden]= self.P(time)&gt;=self.u[time]*self.Pmin
            constraintsD['max-gen-power_'+iden]= self.P(time)&lt;=self.u[time]*self.Pmax
            if len(times)&gt;1: #if UC or SCUC problem
                #start up / shut down
                constraintsD['statusConstant_'+iden]=       self.startup[time]+self.shutdown[time] &lt;= 1
                if t&gt;0: constraintsD['statusChange_'+iden]= self.startup[time]-self.shutdown[time] == self.u[time] - self.u[times[t-1]]
                #up/down time minimums 
                #need to check this for sub-hourly commitment
                if relativedelta(time.Start, startTime).hours &gt; minUpHoursRemainingInit:
                    constraintsD['minuptime_'+iden]= 1 &gt;= self.startup[time]  + sumVars([self.shutdown[times[s]] for s in range(t,min(tEndIndex,t+self.minuptime))])
                if relativedelta(time.Start, startTime).hours &gt; minDnHoursRemainingInit:                
                    constraintsD['mindowntime_'+iden]= 1 &gt;= self.shutdown[time] + sumVars([ self.startup[times[s]] for s in range(t,min(tEndIndex,t+self.mindowntime))])
                #ramping power
                if t&gt;0:
                    constraintsD['rampingLimHi_'+iden]=                     self.P(time) - self.P(times[t-1]) &lt;= self.rampratemax
                    constraintsD['rampingLimLo_'+iden]= self.rampratemin &lt;=     self.P(time) - self.P(times[t-1])

        return constraintsD        
        
    def __str__(self): return 'g{ind}'.format(ind=self.index)
    def __int__(self): return self.index</div>
    def iden(self,t):  return str(self)+str(t)

<div class="viewcode-block" id="Generator.iden"><a class="viewcode-back" href="../documentation.html#powersystems.Generator.iden">[docs]</a>
class Generator_nonControllable(Generator):
    """ Describes a generator with a fixed schedule."""</div></div>
<div class="viewcode-block" id="Generator_nonControllable"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable">[docs]</a>    def __init__(self,schedule=None,
        fuelcost=1,costcurvestring='0',
        mustrun=False,
        Pmin=0,Pmax=None,
        name=None,index=None,bus=None,**kwargs):
        vars(self).update(locals()) #load in inputs
        if Pmax is None: self.Pmax = self.schedule.maxvalue
        self.buildCostModel()
        self.isControllable=False
        
    def P(self,time): return self.schedule.getEnergy(time)
    def status(self,time): return True
<div class="viewcode-block" id="Generator_nonControllable.P"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.P">[docs]</a>    def setInitialCondition(self,time=None, P=None, u=None, hoursinstatus=None):</div>
<div class="viewcode-block" id="Generator_nonControllable.status"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.status">[docs]</a>        if P is None: P=self.schedule.getEnergy(time) #set default power as first scheduled power output</div>
<div class="viewcode-block" id="Generator_nonControllable.setInitialCondition"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.setInitialCondition">[docs]</a>        self.schedule.P[time]=P
    def getstatus(self,t,times): return dict()
    def add_timevars(self,times): return []</div>
<div class="viewcode-block" id="Generator_nonControllable.getstatus"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.getstatus">[docs]</a>    def update_vars(self,times=None,problem=None): return</div>
<div class="viewcode-block" id="Generator_nonControllable.add_timevars"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.add_timevars">[docs]</a>    def fix_timevars(self,times=None): return</div>
<div class="viewcode-block" id="Generator_nonControllable.update_vars"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.update_vars">[docs]</a>    def cost(self,time): return self.operatingcost(time)</div>
<div class="viewcode-block" id="Generator_nonControllable.fix_timevars"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.fix_timevars">[docs]</a>    def operatingcost(self,time): return self.costModel.trueOutput( self.P(time) )</div>
<div class="viewcode-block" id="Generator_nonControllable.cost"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.cost">[docs]</a>    def truecost(self,time): return self.cost(time)</div>
<div class="viewcode-block" id="Generator_nonControllable.operatingcost"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.operatingcost">[docs]</a>    def incrementalcost(self,time): return self.fuelcost*self.costModel.incOutput(self.P(time))</div>
<div class="viewcode-block" id="Generator_nonControllable.truecost"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.truecost">[docs]</a>    def constraints(self,times): return #no constraints</div>
<div class="viewcode-block" id="Generator_nonControllable.incrementalcost"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.incrementalcost">[docs]</a>        </div>
<div class="viewcode-block" id="Generator_nonControllable.constraints"><a class="viewcode-back" href="../documentation.html#powersystems.Generator_nonControllable.constraints">[docs]</a>class Line(object):
    """</div></div>
<div class="viewcode-block" id="Line"><a class="viewcode-back" href="../documentation.html#powersystems.Line">[docs]</a>    Describes a tranmission line. Currently the model
    only considers real power flow under normal conditions.
    
    :param From: name of bus line originates at
    :param To:   name of bus line connects to
    :param X:    line reactance (p.u.)
    :param Pmax: maximum (positive direction) power flow over line
    :param Pmin: maximum (negative direction) power flow over line.
      Defaults to -:attr:`Pmax` if not specified.
    """
    def __init__(self,name='',index=None,From=None,To=None,X=0.05,Pmax=9999,Pmin=None,**kwargs):
        vars(self).update(locals()) #load in inputs
        if self.Pmin is None: self.Pmin=-self.Pmax #reset default to be -Pmax
        self.P,self.price=dict(),dict()
    def add_timevars(self,times):
        for time in times: 
<div class="viewcode-block" id="Line.add_timevars"><a class="viewcode-back" href="../documentation.html#powersystems.Line.add_timevars">[docs]</a>            self.P[time]=newVar(name='P_'+self.iden(time))
        return self.P.values()
    def update_vars(self,times,problem):
        for time in times: self.P[time]=value(self.P[time],problem)</div>
<div class="viewcode-block" id="Line.update_vars"><a class="viewcode-back" href="../documentation.html#powersystems.Line.update_vars">[docs]</a>    def constraints(self,times,buses):
        '''create the constraints for a line over all times'''</div>
<div class="viewcode-block" id="Line.constraints"><a class="viewcode-back" href="../documentation.html#powersystems.Line.constraints">[docs]</a>        constraints=dict()
        for t in times:
            iden = self.iden(t)
            busNames=getattrL(buses,'name')
            iFrom,iTo=busNames.index(self.From),busNames.index(self.To)
            constraints['lineFlow_'+iden]=     self.P[t] == (1/self.X) * sumVars([ buses[iFrom].angle[t],-1*buses[iTo].angle[t] ])
            constraints['lineLimitHi_'+iden]=  self.P[t]&lt;=self.Pmax
            constraints['lineLimitLow_'+iden]= self.Pmin&lt;=self.P[t]
        return constraints
    
    def __str__(self): return 'k{ind}'.format(ind=self.index)
    def __int__(self): return self.index</div>
    def iden(self,t): return str(self)+str(t)
    def getprice(self,time,problem):
<div class="viewcode-block" id="Line.iden"><a class="viewcode-back" href="../documentation.html#powersystems.Line.iden">[docs]</a>        #get congestion price on line</div>
<div class="viewcode-block" id="Line.getprice"><a class="viewcode-back" href="../documentation.html#powersystems.Line.getprice">[docs]</a>        return problem.dual('lineFlow_'+self.iden(time)) #problem.dual('lineLimitHi_'+self.iden(time))+problem.dual('lineLimitLow_'+self.iden(time))    
class Bus(object):
    """</div></div>
<div class="viewcode-block" id="Bus"><a class="viewcode-back" href="../documentation.html#powersystems.Bus">[docs]</a>    Describes a bus (usually a substation where one or more
    tranmission lines start/end).
    
    :param isSwing: flag if the bus is the swing bus 
      (sets the reference angle for the system)
    """
    def __init__(self,name=None,index=None,isSwing=False):
        vars(self).update(locals()) #load in inputs
        self.generators,self.loads=[],[]
        self.angle,self.price=dict(),dict()
    def add_timevars(self,times):
        for time in times: self.angle[time]=newVar(name='angle_'+self.iden(time))
<div class="viewcode-block" id="Bus.add_timevars"><a class="viewcode-back" href="../documentation.html#powersystems.Bus.add_timevars">[docs]</a>        return self.angle.values()
    def update_vars(self,times,problem):
        for time in times: self.angle[time]=value(self.angle[time],problem)</div>
<div class="viewcode-block" id="Bus.update_vars"><a class="viewcode-back" href="../documentation.html#powersystems.Bus.update_vars">[docs]</a>
    def __str__(self):     return 'i{ind}'.format(ind=self.index)    
    def __int__(self):    return self.index</div>
    def iden(self,t):        return str(self)+str(t)
    def Pgen(self,t):   return sumVars([gen.P(t) for gen in self.generators])
<div class="viewcode-block" id="Bus.iden"><a class="viewcode-back" href="../documentation.html#powersystems.Bus.iden">[docs]</a>    def Pload(self,t):  return sumVars([ ld.P(t) for ld in self.loads])</div>
<div class="viewcode-block" id="Bus.Pgen"><a class="viewcode-back" href="../documentation.html#powersystems.Bus.Pgen">[docs]</a>        </div>
<div class="viewcode-block" id="Bus.Pload"><a class="viewcode-back" href="../documentation.html#powersystems.Bus.Pload">[docs]</a>    def constraints(self,times,Bmatrix,buses):
        '''create the constraints for a bus over all times'''</div>
<div class="viewcode-block" id="Bus.constraints"><a class="viewcode-back" href="../documentation.html#powersystems.Bus.constraints">[docs]</a>        def powerBalance(self,t,Bmatrix,allBuses):
            if len(allBuses)==1: lineFlowsFromBus=0
            else: lineFlowsFromBus=sumVars([Bmatrix[self.index][otherBus.index]*otherBus.angle[t] for otherBus in allBuses]) #P_{ij}=sum_{i} B_{ij}*theta_j ???
            return sumVars([ -lineFlowsFromBus,-self.Pload(t),self.Pgen(t) ])

        constraints=dict()
        nBus=len(buses)
        for t in times:
            iden=self.iden(t)
            if nBus&gt;1 and self.isSwing: constraints['swingBus '+iden] = self.angle[t]==0 #swing bus has angle=0
            constraints['powerBalance_'+iden] = powerBalance(self,t,Bmatrix,buses)==0 #power balance must be zero
        return constraints
    def getprice(self,time,problem):
        return problem.dual('powerBalance_'+self.iden(time))</div>
<div class="viewcode-block" id="Bus.getprice"><a class="viewcode-back" href="../documentation.html#powersystems.Bus.getprice">[docs]</a>class Load(object):
    """</div></div>
<div class="viewcode-block" id="Load"><a class="viewcode-back" href="../documentation.html#powersystems.Load">[docs]</a>    Describes a power system load (demand).
    Currently only real power is considered.
    
    :param bus: name of bus that load is on 
      (not required if ED/OPF problem)
    :param schedule: :class:`~schedule.Schedule` object
      (generally created automatically from file
      by :meth:`get_data.build_class_list`)
    """
    def __init__(self,kind='varying',name=None,index=None,bus=None,schedule=None):
        vars(self).update(locals()) #load in inputs
        self.dispatched_power = dict()
    def P(self,time=None): return self.dispatched_power[time] #self.schedule.getEnergy(time)
    def __str__(self): return 'd{ind}'.format(ind=self.index)    
<div class="viewcode-block" id="Load.P"><a class="viewcode-back" href="../documentation.html#powersystems.Load.P">[docs]</a>    def __int__(self): return self.index</div>
    def iden(self,t):     return str(self)+str(t)
    def benifit(self,time=None): return (self.P(time) - self.schedule.getEnergy(time))*config.cost_loadshedding
<div class="viewcode-block" id="Load.iden"><a class="viewcode-back" href="../documentation.html#powersystems.Load.iden">[docs]</a>    def shed(self,time): return self.schedule.getEnergy(time)- value(self.P(time))</div>
<div class="viewcode-block" id="Load.benifit"><a class="viewcode-back" href="../documentation.html#powersystems.Load.benifit">[docs]</a>    def add_timevars(self,times=None,shedding_allowed=False):</div>
<div class="viewcode-block" id="Load.shed"><a class="viewcode-back" href="../documentation.html#powersystems.Load.shed">[docs]</a>        if shedding_allowed: </div>
<div class="viewcode-block" id="Load.add_timevars"><a class="viewcode-back" href="../documentation.html#powersystems.Load.add_timevars">[docs]</a>            for t in times: self.dispatched_power[t]=newVar('Pd_{}'.format(self.iden(t)),low=0,high=self.schedule.getEnergy(t))
        else:
            for t in times: self.dispatched_power[t]=self.schedule.getEnergy(t)
        return self.dispatched_power.values()
    
    def update_vars(self,times,problem):
        for t in times: self.dispatched_power[t]=value(self.dispatched_power[t],problem)</div>
<div class="viewcode-block" id="Load.update_vars"><a class="viewcode-back" href="../documentation.html#powersystems.Load.update_vars">[docs]</a>
    def constraints(self,*args): return #no constraints
    </div>
<div class="viewcode-block" id="Load.constraints"><a class="viewcode-back" href="../documentation.html#powersystems.Load.constraints">[docs]</a>class Load_Fixed(Load):
    """</div></div>
<div class="viewcode-block" id="Load_Fixed"><a class="viewcode-back" href="../documentation.html#powersystems.Load_Fixed">[docs]</a>    Describes a load that does not vary with time.
    This can be an easy way to add a load for an ED/OPF problem,
    or a system baseload.
    
    :param P: real power consumed by load (MW/hr)
    """
    def __init__(self,kind='fixed',name=None,index=None,bus=None,P=0):
        vars(self).update(locals()) #load in inputs
        self.Pfixed = self.P
        del self.P
        self.dispatched_power = dict()
    def P(self,time=None): return self.dispatched_power[time]
    def add_timevars(self,times=None,shedding_allowed=False):
<div class="viewcode-block" id="Load_Fixed.P"><a class="viewcode-back" href="../documentation.html#powersystems.Load_Fixed.P">[docs]</a>        if shedding_allowed: </div>
<div class="viewcode-block" id="Load_Fixed.add_timevars"><a class="viewcode-back" href="../documentation.html#powersystems.Load_Fixed.add_timevars">[docs]</a>            for t in times: self.dispatched_power[t]=newVar('Pd_{}'.format(self.iden(t)),low=0,high=self.schedule.getEnergy(t))
            return self.dispatched_power.values()
        else:
            for t in times: self.dispatched_power[t]=self.Pfixed
            return []
        
    def benifit(self,time=None): return (self.P(time) - self.Pfixed)*config.cost_loadshedding
    </div>
<div class="viewcode-block" id="Load_Fixed.benifit"><a class="viewcode-back" href="../documentation.html#powersystems.Load_Fixed.benifit">[docs]</a>class Network(object):
    """</div></div>
<div class="viewcode-block" id="Network"><a class="viewcode-back" href="../documentation.html#powersystems.Network">[docs]</a>    Creates and contains the admittance matrix (B)
    used in calculating the power balance for OPF problems.
    
    :param buses: list of :class:`~powersystems.Line` objects
    :param lines: list of :class:`~powersystems.Bus` objects
    """
    def __init__(self,buses,lines):
        self.buses=buses
        self.lines=lines
        self.createBmatrix()
    def createBmatrix(self):
        '''create the matrix B: total admittance from bus i to j'''
<div class="viewcode-block" id="Network.createBmatrix"><a class="viewcode-back" href="../documentation.html#powersystems.Network.createBmatrix">[docs]</a>        nB=len(self.buses)
        self.Bmatrix=numpy.zeros((nB,nB))
        namesL=[bus.name for bus in self.buses]
        for line in self.lines:
            busFrom=self.buses[namesL.index(line.From)]
            busTo=self.buses[namesL.index(line.To)]
            self.Bmatrix[busFrom.index,busTo.index]+=-1/line.X
            self.Bmatrix[busTo.index,busFrom.index]+=-1/line.X
        for i in range(0,nB): 
            self.Bmatrix[i,i]=-1*sum(self.Bmatrix[i,:])
</pre></div></div>

          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">minpower</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../why-minpower.html">Why minpower?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../students.html">For Students</a></li>
<li class="toctree-l1"><a class="reference internal" href="../researchers.html">For Researchers</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../economic-dispatch.html">Economic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../optimal-power-flow.html">Optimal Power Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../unit-commitment.html">Unit Commitment</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../documentation.html">Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../collaborate.html">Collaborate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About minpower</a></li>
</ul>

<div class="plusone"><g:plusone></g:plusone></div>
<div id="searchbox" style="display: none">
  <h3>Search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>